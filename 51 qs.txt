#include <iostream>
#include <vector>
#include <chrono>
#include <bitset>
#include <omp.h>

const int SIZE = 9;

void printSudoku(const std::vector<std::vector<int>>& board) {
    for (int i = 0; i < SIZE; ++i) {
        for (int j = 0; j < SIZE; ++j) {
            std::cout << board[i][j] << " ";
        }
        std::cout << std::endl;
    }
}

bool isValid(const std::vector<std::vector<int>>& board, int row, int col, int num,
             std::vector<std::bitset<SIZE + 1>>& rowCheck,
             std::vector<std::bitset<SIZE + 1>>& colCheck,
             std::vector<std::bitset<SIZE + 1>>& boxCheck) {
    return !(rowCheck[row][num] || colCheck[col][num] || boxCheck[3 * (row / 3) + col / 3][num]);
}

void updatePossibilities(int row, int col, int num,
                         std::vector<std::bitset<SIZE + 1>>& rowCheck,
                         std::vector<std::bitset<SIZE + 1>>& colCheck,
                         std::vector<std::bitset<SIZE + 1>>& boxCheck) {
    rowCheck[row].set(num);
    colCheck[col].set(num);
    boxCheck[3 * (row / 3) + col / 3].set(num);
}

void resetPossibilities(int row, int col, int num,
                        std::vector<std::bitset<SIZE + 1>>& rowCheck,
                        std::vector<std::bitset<SIZE + 1>>& colCheck,
                        std::vector<std::bitset<SIZE + 1>>& boxCheck) {
    rowCheck[row].reset(num);
    colCheck[col].reset(num);
    boxCheck[3 * (row / 3) + col / 3].reset(num);
}

bool solveSudoku(std::vector<std::vector<int>>& board,
                 std::vector<std::bitset<SIZE + 1>>& rowCheck,
                 std::vector<std::bitset<SIZE + 1>>& colCheck,
                 std::vector<std::bitset<SIZE + 1>>& boxCheck) {
#pragma omp parallel for collapse(2) schedule(dynamic)
    for (int i = 0; i < SIZE; ++i) {
        for (int j = 0; j < SIZE; ++j) {
            if (board[i][j] == 0) {
                for (int num = 1; num <= SIZE; ++num) {
                    if (isValid(board, i, j, num, rowCheck, colCheck, boxCheck)) {
                        board[i][j] = num;
                        updatePossibilities(i, j, num, rowCheck, colCheck, boxCheck);
                        if (solveSudoku(board, rowCheck, colCheck, boxCheck)) {
                            return true;
                        }
                        board[i][j] = 0;  // Backtrack if the current configuration is not valid
                        resetPossibilities(i, j, num, rowCheck, colCheck, boxCheck);
                    }
                }
                return false;  // No valid number found
            }
        }
    }
    return true;  // The board is solved
}

int main() {
    std::vector<std::vector<int>> board_9x9 = {
            {0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 3, 0, 8, 5},
            {0, 0, 1, 0, 2, 0, 0, 0, 0},
            {0, 0, 0, 5, 0, 7, 0, 0, 0},
            {0, 0, 4, 0, 0, 0, 1, 0, 0},
            {0, 9, 0, 0, 0, 0, 0, 0, 0},
            {5, 0, 0, 0, 0, 0, 0, 7, 3},
            {0, 0, 2, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 4, 0, 0, 0, 9}
    };

    // Initialize check arrays
    std::vector<std::bitset<SIZE + 1>> rowCheck(SIZE + 1);
    std::vector<std::bitset<SIZE + 1>> colCheck(SIZE + 1);
    std::vector<std::bitset<SIZE + 1>> boxCheck(SIZE + 1);

    auto start_time = std::chrono::high_resolution_clock::now();

    // Warm-up OpenMP
#pragma omp parallel
    {
#pragma omp single nowait
        {
            std::vector<int> a(SIZE, 1);
#pragma omp parallel for
            for (int i = 0; i < SIZE; ++i) {
                a[i] = a[i] + 1;
            }
        }
    }

    // Solve Sudoku
    solveSudoku(board_9x9, rowCheck, colCheck, boxCheck);

    auto end_time = std::chrono::high_resolution_clock::now();

    std::cout << "Solved 9x9 Sudoku in "
              << std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time).count()
              << " microseconds" << std::endl;

    printSudoku(board_9x9);

    std::chrono::duration<double> duration = end_time - start_time;

    std::cout << "Solved 9x9 Sudoku in " << duration.count() << " seconds" << std::endl;

    return 0;
}



